CREATE TABLE test_zheap (a int, b int) with(storage_engine='zheap');
INSERT INTO test_zheap VALUES (16777217, 131584);
-- The page contents can vary, so just test that it can be read
-- successfully, but don't keep the output.
SELECT pagesize, version FROM page_header(get_raw_page('test_zheap', 1));
 pagesize | version 
----------+---------
     8192 |       4
(1 row)

SELECT page_checksum(get_raw_page('test_zheap', 1), 1) IS NOT NULL AS silly_checksum_test;
 silly_checksum_test 
---------------------
 t
(1 row)

DROP TABLE test_zheap;
-- check that using any of these functions with a partitioned table would fail
create table test_partitioned (a int) partition by range (a) with(storage_engine='zheap');
select get_raw_page('test_partitioned', 1); -- error about partitioned table
ERROR:  cannot get raw page from partitioned table "test_partitioned"
-- a regular table which is a member of a partition set should work though
create table test_part1 partition of test_partitioned for values from ( 1 ) to (100) with(storage_engine='zheap');
select get_raw_page('test_part1', 1); -- get farther and error about empty table
ERROR:  block number 1 is out of range for relation "test_part1"
drop table test_partitioned;
-- The tuple contents can vary, so we perform some basic testing of zheap_page_items.
-- We perform all the tuple modifications in a single transaction so that t_slot
-- doesn't change if we change trancsation slots in page during compile time.
-- Because of the same reason, we cannot check for all possibile output for
-- t_infomask_info (for example: slot-reused, multilock, l-nokey-ex etc).
create table test_zheap (a int, b text) with(storage_engine='zheap', autovacuum_enabled=false);
begin;
insert into test_zheap (a) select generate_series(1,6);
update test_zheap set a=10 where a=2;
update test_zheap set b='abcd' where a=3;
delete from test_zheap where a=4;
select * from test_zheap where a=5 for share;
 a | b 
---+---
 5 | 
(1 row)

select * from test_zheap where a=6 for update;
 a | b 
---+---
 6 | 
(1 row)

commit;
select  lp,lp_off,lp_flags,lp_len,t_slot,t_infomask2,t_infomask,t_hoff,t_bits,
		t_infomask_info from zheap_page_items(get_raw_page('test_zheap', 1));
 lp | lp_off | lp_flags | lp_len | t_slot | t_infomask2 | t_infomask | t_hoff |  t_bits  | t_infomask_info 
----+--------+----------+--------+--------+-------------+------------+--------+----------+-----------------
  1 |   8112 |        1 |     12 |      1 |        2050 |          1 |      8 | 10000000 | 
  2 |   8096 |        1 |     12 |      1 |        2050 |         33 |      8 | 10000000 | {in-updated}
  3 |   8080 |        1 |     12 |      1 |        2050 |         65 |      8 | 10000000 | {updated}
  4 |   8064 |        1 |     12 |      1 |        2050 |       1041 |      8 | 10000000 | {deleted,l-ex}
  5 |   8048 |        1 |     12 |      1 |        2050 |        897 |      8 | 10000000 | {l-share}
  6 |   8032 |        1 |     12 |      1 |        2050 |       1153 |      8 | 10000000 | {l-ex}
  7 |   8008 |        1 |     17 |      1 |        2050 |          2 |      8 |          | 
(7 rows)

-- Here, we can only check the undo pointer since transaction information may
-- vary with the database state. Let's hope we don't change the size of existing
-- undo records. If undo record size changes in future, we've modify the undoptr
-- here.
select slot_id , undoptr from zheap_page_slots(get_raw_page('test_zheap', 1))
		where slot_id=1;
 slot_id | undoptr 
---------+---------
       1 |     573
(1 row)

drop table test_zheap;
