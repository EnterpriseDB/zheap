src/backend/access/undo/README

Undo Logs
=========

The undo log subsystem provides a way to store data that is needed for
a limited time.  Undo-aware access methods and subsystems can generate
undo records, and they are eventually either executed at rollback time
to reverse the effects of a transaction, or discarded after commit and
after no snapshot could be interested in accessing them.  The storage
format is optimized for efficient recycling of space, and buffered
random access.

Like redo data (the WAL), undo data consists of records identified by
their location within a 64 bit address space.  Unlike redo data, the
addressing space is internally divided up unto multiple numbered logs.
The first 24 bits of an UndoRecPtr identify the undo log number, and
the remaining 40 bits address the space within that undo log.
Using multiple undo logs instead of a single uniform space avoids the
contention that would result from a single insertion point, since each
session can be given sole access to write data into a given undo log.

Like redo data, undo data is stored on disk in numbered segment files
that are recycled as required.  Unlike redo data, undo data is
accessed through the buffer pool.  In this respect it is similar to
regular relation data.  Buffer content is written out to disk during
checkpoints and whenever it is evicted to make space for another page.
However, unlike regular relation data, undo data has a chance of never
being written to disk at all: if a page is allocated and and then
later discarded without an intervening checkpoint and without an
eviction caused by memory pressure, then no disk I/O is generated.

Undo Log Meta-Data
==================

At any given time the set of undo logs that exists is tracked in
shared memory and can be inspected with the pg_stat_undo_logs view.  For
each undo log, a set of meta-data properties is tracked:
tracked, including:

* the tablespace that holds its segment files
* the category (permanent, unlogged, temporary, shared)
* the "discard" pointer: data before this point has been discarded
* the "insert" pointer: new data will be written here
* the "end" pointer: a new undo segment file will be needed at this point

The three pointers move strictly forwards until the whole undo log has
been exhausted.  At all times discard <= insert <= end.  When discard
== insert, the undo log is empty (everything that has ever been inserted
has since been discarded).

The insert pointer advances when regular backends allocate new space,
and the discard pointer usually advances when an undo worker process
determines that no session could need the data either for rollback or
for finding old versions of tuples to satisfy a snapshot.  In some
special cases including single-user mode and temporary undo logs the
discard pointer might also be advanced synchronously by a foreground
session.

UndoLogSlot objects corresponding to the current set of active undo
logs are held in a fixed-sized pool in shared memory.  The size of the
array is a multiple of max_connections.  This effectively limits the
total size of an active transaction, since the undo data it generates
must by able to be tracked by the number of slots in the pool, though
the number of slots and size per slot (1TB) are large enough that it
should never in practice be reached.

In order to provide constant time access to undo log meta-data given
an UndoRecPtr, each backend maintains a hash table mapping undo log
number to shared UndoLogSlot objects.  The objects in shared memory
are unordered so need to be found by linear search on first look-up by
each backend.

The meta-data for all undo logs is written to disk at every
checkpoint.  It is stored in files under PGDATA/pg_undo/, using the
checkpoint's redo point (a WAL LSN) as its filename.  At startup time,
the redo point's file can be used to restore all undo logs' meta-data
as of the moment of the redo point into shared memory.  Changes to the
discard pointer and end pointer are WAL-logged by undolog.c and will
bring the in-memory meta-data up to date in the event of recovery
after a crash.  Changes to insert pointers are implied by other WAL
records (see below) to minimize WAL traffic.

Responsibility for creating, deleting and recycling undo log segment
files and WAL logging the associated meta-data changes lies with
src/backend/storage/undo/undolog.c.

Persistence Levels and Tablespaces
==================================

When new undo log space is requested by client code, the persistence
level of the corresponding relation being modified and the current
value of the GUC "undo_tablespaces" controls which undo log is selected.
If the session is already attached to a suitable undo log and it hasn't
run out of address space, it can be used immediately.  Otherwise a
suitable undo log must be either found or created.  The system should
stabilize on one undo log per active writing backend (or more if
different tablespaces and persistence levels are used).

When an unlogged relation is modified, undo data generated by the
operation must be stored in an unlogged undo log.  This causes the
undo data to be deleted along with all unlogged relations during
recovery from a non-shutdown checkpoint.  Likewise, temporary
relations require special treatment: their buffers are backend-local
and they cannot be accessed by other backend including undo workers.

Non-empty undo logs in a tablespace prevent the tablespace from being
dropped.

Undo Log Contents
=================

Undo log contents are written into 1MB segment files under
PGDATA/base/undo/ or PGDATA/pg_tblspc/VERSION/undo/ using filenames
that encode the address (UndoRecPtr) of their first byte.  A period
'.'  separates the undo log number part from the offset part, for the
benefit of humans.

Undo logs are page-oriented and use regular PosgreSQL page headers
including checksums (if enabled) and LSNs.  An UndoRecPtr can be used
to obtain a buffer and an offset within the buffer, and then regular
buffer locking and page LSN rules apply.  While space is allocated by
asking for a given number of usable bytes (not including page
headers), client code is responsible for stepping over the page
headers and advancing to the next page.

Responsibility for WAL-logging the contents of undo logs lies with
client code (ie undo-aware access managers).  undolog.c WAL-logs
all meta-data changes except insert pointer changes.  Client code
is responsible for generating exactly the same undo log data at
recovery time.  This means that the insert pointer doesn't need to
be explicitly logged as undo space is allocated, keepign WAL traffic
low.  WAL is still generated by undolog.c whenever an undo segment
boundary is crossed, since that performs filesystem operations and
also advances the end pointer.

One complication of this scheme for implicit insert pointer movement
is that recovery doesn't naturally have access to the association
between transactions and undo logs.  To deal with that, at recovery
time UndoLogAllocateInRecovery() checks which blocks were registered
as being dirtied by the WAL record that is currently being replayed.
Then it only needs to infer the exact position within the page where
the record needs to be placed incrementally, as each record is
allocated.

A further complication is that the checkpoint files written under
pg_undo may contain inconsistent data during recovery from an online
checkpoint (after a crash or base backup).  To compensate for this,
an image of the undo log's meta-data is attached to the page in the
WAL the first time each undo log page is registered after a
checkpoin.  These images are restored whenever they are encountered
during recovery.
